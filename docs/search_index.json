[["index.html", "ML Guide Preface", " ML Guide Greg Rompala 2020-10-22 Preface Iterative machine learning regression modeling.Build models for multiple traits with multiple important feature number cut-offs. Data Visualization techniques using ggplot2 and gganimate. "],["supervised-regression-modelling.html", "Chapter 1 Supervised Regression Modelling 1.1 Training and Testing 1.2 Examining the Results", " Chapter 1 Supervised Regression Modelling This is the basic framework. Nested CV will allow for using several training-test paritions in parallel in the outer loop. The inner-loop features cross-validation with 5 folds of the training data. Finally, backward selection of gene features allows you to build new models with a specified amout of most important features as determined from the training model. 1.1 Training and Testing Here we are going to use placental gene expression to predict maternal age and emotional regulation in children. # Load necessary packages suppressPackageStartupMessages({ library(caret) library(DESeq2) library(e1071) library(pROC) library(plyr) library(stringr) library(dplyr) library(mboost) library(gbm) library(DESeq2) library(dplyr) library(pls) library(ggplot2) library(ggpubr) library(gganimate) library(gapminder) library(cowplot) library(directlabels) library(gifski) library(transformr) library(RUncommon) }) working.dir=&quot;C:/Users/grrompala/Desktop&quot; # working directory setwd(working.dir) # Load in your gene counts and metadata counts &lt;- read.csv(&quot;counts.csv&quot;,header=T,row.names=1) # raw gene counts for each subject meta &lt;- read.csv(&quot;meta.csv&quot;,header=T,row.names=1) # metadata with 2 outcomes we will predict for each subject head(counts[1:10,1:10]) ## S_1 S_10 S_100 S_103 S_106 S_107 S_108 S_109 S_10Q S_11 ## A1BG-AS1 16 16 16 14 23 15 26 16 13 9 ## A2M 30620 14070 24203 31400 43652 30419 34490 22477 33795 10351 ## A2M-AS1 20 18 38 28 17 27 27 29 22 12 ## A2ML1 165 22 7 4 31 8 14 10 13 18 ## A2MP1 3 3 18 16 5 1 19 23 11 12 ## A4GALT 1168 516 702 607 1147 462 687 822 628 622 head(meta[1:10,]) ## STAI_TTO REG ## S_1 20 6.583333 ## S_10 34 4.345238 ## S_100 36 4.960000 ## S_103 27 6.232143 ## S_106 41 5.540000 ## S_107 31 4.600000 # Filter and normalize gene counts: we will use rowMeans&gt;10 as a filter counts &lt;- counts[rowMeans(counts)&gt;10,] counts &lt;- varianceStabilizingTransformation(as.matrix(counts)) counts &lt;- t(counts) # Filter metadata and subjects that are missing metadata for mom age or child emotional regulation Here we will employ common techniques employed to reduce number of predictors that may be introducing noise # Filter counts by coefficient of variance coef.var&lt;-apply(subset(counts),2,function(x)sd(x)/mean(x)) # calculate coefficent of variance (CV) genes2keep&lt;-names(coef.var)[which(coef.var&gt;0.05)] # extract genes to keep after CV threshold coef_counts&lt;-counts[,c(genes2keep)] # filter by genes to keep #paste(&quot;Number of Genes Remaining:&quot;,length(colnames(coef_counts)),sep=&quot; &quot;) # Filter counts using dimensionality reduction CorrelationMatrix&lt;-cor(coef_counts[,-1]) highlyCorrelated&lt;-findCorrelation(CorrelationMatrix,cutoff=0.9,names=TRUE) # Filters genes with correlation R values greater than 0.8 (keeping the gene with least co-linearity) COUNTS &lt;-coef_counts[,setdiff(colnames(coef_counts),highlyCorrelated)] paste(&quot;Number of Genes Remaining:&quot;,length(colnames(COUNTS)),sep=&quot; &quot;) ## [1] &quot;Number of Genes Remaining: 5885&quot; set.seed(1097) # Set seed for reproducible results! Now, we will loop through our two outcome variables, building a partial least squares regression model for each #global-options,include=TRUE,warning=FALSE} #knitr::opts_chunk$set(warning=FALSE,message=FALSE,include=FALSE) # Settings to repress warning messages in the chunk options(width = 60) outcomes &lt;- colnames(meta) # should be mother&#39;s trait anxiety and emotional regulation as vector model &lt;- c(&quot;glmnet&quot;) # set model variables &lt;- c(100,1000,5000) # Set how many ranked important variables to rebuild model with # Initialize data summaries final.summary &lt;- data.frame(Buffer=character(),stringsAsFactors = FALSE) all.predictions &lt;- data.frame(holder=character(), stringsAsFactors=FALSE) resample.summary &lt;- data.frame(holder=character(), stringsAsFactors=FALSE) varImp.summary &lt;- data.frame(blank=&quot;&quot;) # Looping through both traits and both features cut-offs (100,1000) for (trait in outcomes) { metaF &lt;- meta %&gt;% filter(is.na(meta[[trait]])==F) # filter out NAs from outcome variable counts &lt;- COUNTS[rownames(metaF),] # filter subjects in counts with new metadata working.META &lt;- metaF[[trait]] # filters metadata for outcome names(working.META) &lt;- rownames(metaF) train.parts &lt;- createDataPartition(working.META,p=0.8,list=TRUE,times=10) # makes training and test sets #(Here I am making 25 training-test splits of 80% train and 20% test) cv.settings &lt;- trainControl(method=&quot;repeatedcv&quot;,number=5,repeats=3) # cross-validation with #splits data into 5 folds and repeats this three times # Train regression model for each of your partitions Regression.Models &lt;-lapply(train.parts, function(L){ X.train &lt;- counts[L,] Y.train &lt;- working.META[L] train.parts &lt;- rownames(X.train) model.one &lt;-train(y=Y.train, x=X.train, method=model, trControl = cv.settings, trace=FALSE) importance&lt;- varImp(model.one)$importance # outputs variables ranked by importance score TrainID&lt;-names(Y.train) return(list(MODEL=model.one,TrainID=TrainID,importance=importance,train.parts=train.parts)) }) # Empty DFs to iterate through different feature variable cut-offs df &lt;- data.frame(New=character(), stringsAsFactors=FALSE) predictionsT &lt;- data.frame(New=character(), stringsAsFactors=FALSE) resamplesT &lt;- data.frame(New=character(), stringsAsFactors=FALSE) for (import_num in variables) # Choose a few important variable cutoffs { VarImport.Models &lt;- lapply(Regression.Models, function(L){ importance &lt;- L$importance varImps &lt;- rownames(importance[order(importance$Overall,decreasing=T),,drop=FALSE])[1:import_num] varImps &lt;- str_remove_all(varImps,&quot;`&quot;) train.parts &lt;- L$train.parts X.train&lt;- counts[train.parts,varImps] Y.train&lt;- working.META[train.parts] model.one &lt;-train(y=Y.train, x=X.train, method=model, trControl = cv.settings, trace=FALSE) TrainID&lt;-names(Y.train) return(list(MODEL=model.one,TrainID=TrainID,varImps=varImps))}) # Compile model results VarImport.Models.Results &lt;- lapply(VarImport.Models,function(L){ ok&lt;- getTrainPerf(L$MODEL) return(ok) }) RM.Results &lt;- ldply(VarImport.Models.Results,rbind) # Use trained model on test dataset Regression.Predictions&lt;-lapply(VarImport.Models, function(L){ TrainID&lt;-L$TrainID TestID&lt;-setdiff(rownames(counts),TrainID) MODEL&lt;-L$MODEL varImps &lt;- L$varImps X.test&lt;- counts[TestID,varImps] Y.test&lt;-working.META[TestID] model.preds&lt;-predict(MODEL,X.test) table.preds&lt;-cbind.data.frame(PRED=model.preds,REAL=Y.test) table.preds$SampleID&lt;-rownames(table.preds) RMSE &lt;- RMSE(model.preds,Y.test) correlation &lt;- cor(model.preds,Y.test) return(list(testRMSE=RMSE,table.preds=table.preds,testR=correlation))}) # Generate best RMSEs and correlation R values for all test partitions RMSE &lt;- lapply(Regression.Predictions,function(L){ RMSE &lt;- L$testRMSE return(RMSE)}) RMSE &lt;-do.call(&quot;rbind.data.frame&quot;,RMSE) colnames(RMSE) &lt;- NULL # Get correlation between predictions and real scores for each train-test partition corr &lt;- lapply(Regression.Predictions,function(L){ corr &lt;- L$testR return(corr)}) corr &lt;-do.call(&quot;rbind.data.frame&quot;,corr) colnames(corr) &lt;- NULL # Compile results for each resample results &lt;- cbind(RM.Results,RMSE,corr) results$trait &lt;- trait results$var.num &lt;- import_num resamplesT &lt;- rbind.fill(resamplesT,results) ## Compile results summarizing each resample per trait and number of features RM.Result &lt;- RM.Results[,2:4] averages &lt;- cbind(RM.Result,RMSE,corr) averagez &lt;- colMeans(averages) averages &lt;- append(trait,averagez) averages &lt;- append(import_num,averages) x &lt;- data.frame(t(averages)) colnames(x)[1:2] &lt;- c(&quot;Feature.number&quot;,&quot;Trait&quot;) df &lt;- rbind.fill(df,x) ## Bind and write all predictions out to file Regression.Predictions &lt;- lapply(Regression.Predictions,function(L){ Regression.Predictions &lt;- L$table.preds return(Regression.Predictions)}) Regression.Predictions &lt;- mapply(`[&lt;-`, Regression.Predictions, &#39;Partition&#39;, value = names(Regression.Predictions), SIMPLIFY = FALSE) Regression.Predictions &lt;- bind_rows(Regression.Predictions) Regression.Predictions$trait &lt;- trait Regression.Predictions$feat.num &lt;- as.factor(import_num) predictionsT &lt;- rbind.fill(predictionsT,Regression.Predictions) # print(paste(import_num,&quot;done&quot;,sep=&quot; &quot;) } # Write gene importance out to file varImp.list &lt;-lapply(Regression.Models, function(L){ importance&lt;-varImp(L$MODEL) return(importance$importance)}) varImp.list &lt;- do.call(&quot;cbind&quot;,varImp.list) colnames(varImp.list) &lt;- c(paste(&quot;Resample.&quot;,1:length(colnames(varImp.list)),sep=&quot;&quot;)) avg.varImp &lt;- rowMeans(varImp.list) # Bind results for each trait used varImp.summary &lt;- cbind(varImp.summary,avg.varImp) final.summary &lt;- rbind.fill(final.summary,df) all.predictions &lt;- rbind.fill(all.predictions,predictionsT) resample.summary &lt;- rbind.fill(resample.summary,resamplesT) } Clean up the results data frames and perhaps write results to file # remove excess all.predictions &lt;- all.predictions[,-c(1:2)] resample.summary &lt;- resample.summary[,-c(1:2)] final.summary &lt;- final.summary[,-c(1:2)] varImp.summary &lt;- varImp.summary[,-1] colnames(varImp.summary) &lt;- outcomes # write.csv(final.summary[,-c(1:2)],file=&quot;Summary.REG.varImp.GLMNET.csv&quot;) # write.csv(all.predictions[,-1],file=&quot;PREDICTIONS.REG.varImp.GLMNET.csv&quot;) # write.csv(resample.summary,file=&quot;Resample.REG.varImp.GLMNET.csv&quot;) # write.csv(varImp.summary,file=&quot;VarImp.summary.csv&quot;) 1.2 Examining the Results Here we depict predictions vs real values. Note all subjects are represented as we took the average prediction across all 10 test partitions. # results for emtoional regulation ok &lt;- ggscatter(all.predictions %&gt;% filter(trait==&quot;REG&quot;), x=&quot;PRED&quot;, y=&quot;REAL&quot;, color=&quot;feat.num&quot;, add=&quot;reg.line&quot;, mean.point = T, title=&quot;Predicting Emotional Regulation from Placental Gene Expression&quot;, mean.point.size=9, palette=&quot;Set2&quot;, facet.by = &quot;feat.num&quot;, xlab=&quot;PREDICTED VALUE&quot;, ylab=&quot;REAL VALUE&quot;)+ stat_cor(method = &quot;pearson&quot;,show.legend = F)+ theme(plot.title = element_text(hjust = 0.5)) ok &lt;- ggpar(ok,legend.title= &quot;Number of Important Features&quot;,legend=&quot;bottom&quot;) ok ## `geom_smooth()` using formula &#39;y ~ x&#39; The same thing here, just using gganimate p &lt;- ggplot(all.predictions %&gt;% filter(trait==&quot;REG&quot;), aes(x=PRED, y=REAL)) + geom_point(alpha = 0.7, show.legend = FALSE) + geom_smooth(method=&#39;lm&#39;, formula= y~x)+ stat_smooth_func(geom=&quot;text&quot;,method=&quot;lm&quot;,hjust=0,parse=TRUE)+ # stat_regline_equation()+ #scale_colour_manual(values = country_colors) + #scale_size(range = c(2, 12)) + #scale_x_log10() + #facet_wrap(~continent) + # Here comes the gganimate specific bits labs(title=&quot;Child Emotional Regulation&quot;,subtitle = &quot;Number of Features: {closest_state}&quot;, x = &#39;PREDICTED&#39;, y = &#39;REAL&#39;) + transition_states(feat.num) + theme( plot.title = element_text(face=&quot;bold&quot;) ) animate(p, duration = 5, fps = 50, width = 500, height = 500, renderer = gifski_renderer()) #anim_save(&quot;output.gif&quot;) RMSE (Root Mean Square Error) is used to evaluate test performance. This tells you the average difference between the real and predicted values (i.e, the residual). resample.stat &lt;- resample.summary %&gt;% filter(trait==&quot;REG&quot;) %&gt;% group_by(var.num) %&gt;% summarise( mean=mean(RMSE), se=sd(RMSE)/sqrt(n())) ggplot(resample.stat,aes(x=var.num,y=mean))+ geom_line(color=&quot;black&quot;,size=1)+ geom_point(color=&quot;red&quot;,size=5)+ geom_errorbar(aes(ymin = mean - se, ymax = mean + se), color=&quot;red&quot;,width=300,size=1)+ labs(title=&quot;Emotional Regulation: Test Performance&quot;, x = &#39;Features&#39;, y = &#39;Mean RMSE&#39;,hjust=0.5)+ scale_x_continuous(breaks=c(100,1000,5000))+ ylim(0.5,.75)+ theme(plot.title=element_text(size=18,face=&quot;bold&quot;), axis.title=element_text(size=14,face=&quot;bold&quot;), axis.text.x = element_text(size=12), axis.text.y=element_text(size=12)) Showing how RMSE changed with each resampling test partition resample.summary$ID &lt;- rep(1:10,times=6,each=1) p &lt;- ggplot(resample.summary %&gt;% filter(trait==&quot;REG&quot;), aes(x=ID, y=RMSE,group=as.factor(var.num),color=as.factor(var.num))) + geom_line()+ geom_point(alpha = 0.7, show.legend = FALSE) + scale_x_continuous(breaks=c(1:10))+ scale_color_discrete(name=&quot;Number of Impotant Features&quot;)+ labs(x=&quot;Resample number&quot;,y=&quot;RMSE&quot;,title=&quot;Emotional Regulation:Test Performance&quot;)+ transition_reveal(ID) + theme( plot.title = element_text(face=&quot;bold&quot;) ) animate(p, duration = 8, fps = 50, width = 700, height = 500, renderer = gifski_renderer(),end_pause = 100) #anim_save(&quot;output.gif&quot;) Taking a look at most important variables for each trait ## Sort by highest importance to lowest #m &lt;- varImp.summary %&gt;% arrange(desc(REG)) #ggplot(aes(x=`car name`, y=mpg_z, label=mpg_z)) + #geom_bar(stat=&#39;identity&#39;, aes(fill=mpg_type), width=.5) + # scale_fill_manual(name=&quot;Mileage&quot;, # labels = c(&quot;Above Average&quot;, &quot;Below Average&quot;), # values = c(&quot;above&quot;=&quot;#00ba38&quot;, &quot;below&quot;=&quot;#f8766d&quot;)) + #labs(subtitle=&quot;Normalised mileage from &#39;mtcars&#39;&quot;, # title= &quot;Diverging Bars&quot;) + # coord_flip() "]]
